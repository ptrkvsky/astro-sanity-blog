---
category: React
date: '2022-01-12'
dateModified: '12 January 2022'
datePublished: '12 January 2022'
description: Tout savoir pour bien typer une fonction avec Typescript.
image: '/images/typescript-react.png'
isHome: true
slug: 'fonction-typescript'
title: Comment typer une fonction avec Typescript
metaTitle: Retrouvez un article complet sur comment bien typer une fonction avec Typescript
metaDescription: Retrouvez tout ce qu'il faut savoir pour bien typer les fonctions de votre application avec Typescript.
---

import { Image } from '@astrojs/image/components';
import banner from '@assets/images/typescript-fonction.jpg';

<Image
  alt={`Illustration Typescript et React`}
  src={banner}
  width={880}
  height={880}
  priority
/>

<blockquote cite="https://kentcdodds.com/blog/typescript-function-syntaxes">
  Cet article est une traduction de l'article{' '}
  <a
    rel="follow"
    href="https://kentcdodds.com/blog/typescript-function-syntaxes"
  >
    TypeScript Function Syntaxes
  </a>
  <br />
  par Kent C. Dodds.
</blockquote>

En JavaScript m√™me, il existe de nombreuses fa√ßons d'√©crire des fonctions. Ajoutez TypeScript √† l'ensemble et tout d'un coup, il y a mati√®re √† r√©fl√©chir. Avec l'aide de [quelques](https://twitter.com/kentcdodds/status/1365046763892084736) [amis](https://gist.github.com/kentcdodds/61176c067ec5250b5bd3c7fe57a0120d), j'ai donc dress√© une <strong>liste des diff√©rentes formes de fonctions</strong> dont vous aurez g√©n√©ralement besoin, avec des exemples simples.

N'oubliez pas qu'il existe des tonnes de combinaisons de syntaxes diff√©rentes. Je n'ai inclus que celles qui sont des combinaisons moins √©videntes ou uniques d'une certaine mani√®re.

Tout d'abord, la plus grande confusion que j'ai toujours eue avec la syntaxe des choses est de savoir o√π placer le type de retour.

Quand dois-je utiliser `:` et quand dois-je utiliser `=>`.

Voici quelques exemples rapides qui pourraient vous aider √† acc√©l√©rer le processus si vous utilisez cet article comme r√©f√©rence rapide :

```ts
// Type simple pour une fonction, utiliser =>
type FnType = (arg: ArgType) => ReturnType;

// Les autres fois, utiliser :
type FnAsObjType = {
  (arg: ArgType): ReturnType;
};
interface InterfaceWithFn {
  fn(arg: ArgType): ReturnType;
}

const fnImplementation = (arg: ArgType): ReturnType => {
  /* implementation */
};
```

Je pense que c'√©tait la plus grande source de confusion pour moi. Apr√®s avoir √©crit ceci, je sais maintenant que la seule fois o√π j'utilise `=> ReturnType` est lorsque je d√©finis un type de fonction comme un type en soi. Le reste du temps, il faut utiliser `: ReturnType`.

Continuez √† lire pour un tas d'exemples de comment cela se passe dans des exemples de code typiques.

## D√©claration d'une fonction

```ts
// Le type du retour est d√©duit/inf√©r√©
function sum(a: number, b: number) {
  return a + b;
}
```

```ts
// Le type du retour est d√©fini
function sum(a: number, b: number): number {
  return a + b;
}
```

Dans les exemples ci-dessous, nous utiliserons des types de retour explicites, mais techniquement, il n'est pas n√©cessaire de le pr√©ciser.

## Expression d'une fonction

```ts
<g>
```

```ts
// expression d'une fonction anonyme
const sum = function (a: number, b: number): number {
  return a + b;
};
```

```ts
// expression d'une fonction fl√©ch√©e
const sum = (a: number, b: number): number => {
  return a + b;
};
```

```ts
// expression d'une fonction implicite
const sum = (a: number, b: number): number => a + b;
// Le retour implicite d'un objet n√©cessite des parenth√®ses pour d√©sambigu√Øser les accolades.
```

```ts
const sum = (a: number, b: number): { result: number } => ({ result: a + b });
```

Vous pouvez √©galement ajouter une annotation de type √† c√¥t√© de la variable, et la fonction elle-m√™me assumera alors ces types :

```ts
const sum: (a: number, b: number) => number = (a, b) => a + b;
```

Vous pouvez √©galement extraire le type

```ts
type MathFn = (a: number, b: number) => number;

const sum: MathFn = (a, b) => a + b;
```

Vous pouvez aussi utiliser la syntaxe du type d'objet :

```ts
type MathFn = {
  (a: number, b: number): number;
};

const sum: MathFn = (a, b) => a + b;
```

Ce qui peut √™tre utile si vous voulez ajouter une propri√©t√© typ√©e √† la fonction :

```ts
type MathFn = {
  (a: number, b: number): number;
  operator: string;
};

const sum: MathFn = (a, b) => a + b;
sum.operator = '+';
```

Cela peut √©galement √™tre fait avec une interface :

```ts
interface MathFn {
  (a: number, b: number): number;
  operator: string;
}
const sum: MathFn = (a, b) => a + b;
sum.operator = '+';
```

Et puis il y a `declare function` et `declare namespace` qui sont destin√©s √† dire : "H√©, il existe une variable avec ce nom et ce type".
Nous pouvons l'utiliser pour cr√©er le type, puis utiliser `typeof` pour affecter ce type √† notre fonction.
Vous trouverez souvent `declare` utilis√© dans les fichiers `.d.ts` pour d√©clarer les types des biblioth√®ques.

```ts
declare function MathFn(a: number, b: number): number;

declare namespace MathFn {
  let operator: '+';
}

const sum: typeof MathFn = (a, b) => a + b;
sum.operator = '+';
```

Si j'ai le choix entre le type, l'interface et la fonction `declare`, <b>je pense que je pr√©f√®re personnellement le type</b>,
sauf si j'ai besoin de l'extensibilit√© qu'offre l'interface.
Je n'utiliserais vraiment `declare` que si je voulais vraiment informer le compilateur de quelque chose qu'il ne conna√Æt pas encore (comme une biblioth√®que).

## Param√®tres par d√©faut et optionnels dans une fonction Typescript

### Param√®tre optionnel d'une fonction Typescript

```ts
const sum = (a: number, b?: number): number => a + (b ?? 0);
```

Notez que l'ordre est important ici. Si vous rendez un param√®tre facultatif, tous les param√®tres suivants doivent l'√™tre √©galement.
En effet, il est possible d'appeler `sum(1)` mais pas `sum(, 2)`. Cependant, il est possible d'appeler `sum(ind√©fini, 2)`
et si c'est ce que vous voulez activer, vous pouvez le faire aussi :

```ts
const sum = (a: number | undefined, b: number): number => (a ?? 0) + b;
```

### Param√®tre par d√©faut d'une fonction Typescript

Lorsque j'√©crivais ceci, je pensais qu'il serait inutile d'utiliser des param√®tres par d√©faut sans rendre ce param√®tre optionnel,
mais il s'av√®re que lorsque vous avez une valeur par d√©faut, TypeScript la traite comme un param√®tre optionnel. Donc cela fonctionne :

```ts
const sum = (a: number, b: number = 0): number => a + b;
sum(1); // r√©sultat 1
sum(2, undefined); // r√©sultat 2
```

Cet exemple est donc fonctionnellement √©quivalent √† :

```ts
const sum = (a: number, b: number | undefined = 0): number => a + b;
```

Il est int√©ressant de noter que cela signifie √©galement que si vous souhaitez que le premier argument soit facultatif
mais que le second soit obligatoire, vous pouvez le faire sans utiliser `| undefined`.

```ts
const sum = (a: number = 0, b: number): number => a + b;

sum(undefined, 3); // r√©sultat 3
```

Toutefois, lorsque vous extrayez le type, vous devez ajouter manuellement le signe `| undefined`, car `= 0` est une expression JavaScript et non un type.

```ts
type MathFn = (a: number | undefined, b: number) => number;

const sum: MathFn = (a = 0, b) => a + b;
```

## Param√®tres du reste (Rest parameters)

Rest params est une fonctionnalit√© JavaScript qui vous permet de rassembler le "reste" des arguments d'un appel de fonction dans un tableau.
Vous pouvez les utiliser √† n'importe quelle position de param√®tre (premier, deuxi√®me, troisi√®me, etc.).
La seule exigence est qu'il s'agisse du dernier param√®tre.

```ts
const sum = (a: number = 0, ...rest: Array<number>): number => {
  return rest.reduce((acc, n) => acc + n, a);
};
```

Et vous pouvez extraire le type :

```ts
type MathFn = (a?: number, ...rest: Array<number>) => number;

const sum: MathFn = (a = 0, ...rest) => rest.reduce((acc, n) => acc + n, a);
```

## Propri√©t√©s et m√©thodes des objets

### M√©thodes des objets dans une fonction Typescript

```ts
const math = {
  sum(a: number, b: number): number {
    return a + b;
  },
};
```

### Propri√©t√© comme expression de fonction

```ts
const math = {
  sum: function sum(a: number, b: number): number {
    return a + b;
  },
};
```

Propri√©t√© en tant qu'expression de fonction fl√©ch√©e (avec retour implicite) :

```ts
const math = {
  sum: (a: number, b: number): number => a + b,
};
```

Malheureusement, pour extraire le type, vous ne pouvez pas taper la fonction elle-m√™me, vous devez taper l'objet qui l'entoure.
Il est impossible d'annoter la fonction avec un type lorsqu'elle est d√©finie dans un objet litt√©ral :

```ts
type MathFn = (a: number, b: number) => number;

const math: { sum: MathFn } = {
  sum: (a, b) => a + b,
};
```

De plus, si vous voulez lui ajouter une propri√©t√© comme dans certains des exemples ci-dessus,
il est impossible de le faire dans l'objet litt√©ral.
Vous devez extraire compl√®tement la d√©finition de la fonction :

```ts
type MathFn = {
  (a: number, b: number): number;
  operator: string;
};
const sum: MathFn = (a, b) => a + b;
sum.operator = '+';

const math = { sum };
```

Vous avez peut-√™tre remarqu√© que cet exemple est identique √† un exemple pr√©c√©dent avec seulement l'ajout de la const `math = {sum}`.
Donc oui, il n'y a aucun moyen de faire tout cela en ligne avec la d√©claration d'objet.

## Comment typer les fonctions dans les classes avec Typescript

Les classes elles-m√™mes sont des fonctions, mais elles sont sp√©ciales (elles doivent √™tre invoqu√©es avec `new`), mais cette section traitera de la fa√ßon dont les fonctions sont d√©finies dans le corps de la classe.

Voici une m√©thode ordinaire, la forme la plus courante d'une fonction dans le corps d'une classe :

```ts
class MathUtils {
  sum(a: number, b: number): number {
    return a + b;
  }
}

const math = new MathUtils();
math.sum(1, 2);
```

Vous pouvez √©galement utiliser un champ de classe si vous souhaitez que la fonction soit li√©e √† l'instance sp√©cifique de la classe :

```ts
class MathUtils {
  sum = (a: number, b: number): number => {
    return a + b;
  };
}

// Faire cela comme √ßa vous autorise √† :
const math = new MathUtils();
const sum = math.sum;
sum(1, 2);

// mais cela a aussi un co√ªt qui annule les gains de performance que vous obtenez
// en choisissant une classe plut√¥t qu'un objet ordinaire, donc...
```

Et ensuite vous pouvez extraire ces types. Voici √† quoi cela ressemble avec notre premier exemple

```ts
interface MathUtilsInterface {
  sum(a: number, b: number): number;
}

class MathUtils implements MathUtilsInterface {
  sum(a: number, b: number): number {
    return a + b;
  }
}
```

Il est int√©ressant de noter qu'il semble que vous devez toujours d√©finir les types de la fonction, m√™me si ceux-ci font partie de l'interface qu'elle est cens√©e impl√©menter ü§î ü§∑‚ôÇÔ∏è.

Une derni√®re remarque. En TypeScript, vous avez aussi `public`, `private` et `protected`. Personnellement, je n'utilise pas si souvent les classes et je n'aime pas utiliser ces fonctionnalit√©s particuli√®res de TypeScript.

JavaScript aura bient√¥t une syntaxe sp√©ciale pour les membres priv√©s, ce qui est g√©nial [en savoir plus](https://github.com/tc39/proposal-class-fields).

## Les Modules

L'importation et l'exportation de d√©finitions de fonctions fonctionnent de la m√™me mani√®re qu'avec n'importe quel autre √©l√©ment.
L√† o√π les choses deviennent uniques pour TypeScript, c'est si vous voulez √©crire un fichier `.d.ts` avec une d√©claration de module.
Prenons par exemple notre fonction `sum` comme exemple :

```ts
const sum = (a: number, b: number): number => a + b;
sum.operator = '+';
```

Voici ce que nous ferions en supposant que nous l'exportons par d√©faut :

```ts
declare const sum: {
  (a: number, b: number): number;
  operator: string;
};
export default sum;
```

Et dans le cas o√π nous souhaitons un export nomm√© :

```ts
declare const sum: {
  (a: number, b: number): number;
  operator: string;
};
export { sum };
```

## Surcharges

J'ai √©crit sur ce sujet en particulier et vous pouvez le lire : [D√©finir des types de surcharge de fonction avec TypeScript](https://kentcdodds.com/blog/define-function-overload-types-with-type-script). Voici l'exemple de cet article :

```ts
type asyncSumCb = (result: number) => void;
// define all valid function signatures
function asyncSum(a: number, b: number): Promise<number>;
function asyncSum(a: number, b: number, cb: asyncSumCb): void;
// define the actual implementation
// notice cb is optional
// also notice that the return type is inferred, but it could be specified
// as `void | Promise<number>`
function asyncSum(a: number, b: number, cb?: asyncSumCb) {
  const result = a + b;
  if (cb) return cb(result);
  else return Promise.resolve(result);
}
```

En fait, il s'agit de d√©finir la fonction plusieurs fois et de ne l'impl√©menter que la derni√®re fois. Il est important que les types de l'impl√©mentation supportent tous les types de surcharge, c'est pourquoi le `cb` est optionnel ci-dessus.

## G√©n√©rateurs

Je n'ai pas utilis√© une seule fois un g√©n√©rateur dans du code de production... Mais quand j'ai jou√© un peu avec dans la cour de r√©cr√©ation de TypeScript, il n'y avait pas grand chose √† faire pour le cas simple :

```ts
function* generator(start: number) {
  yield start + 1;
  yield start + 2;
}

var iterator = generator(0);
console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

TypeScript d√©duit correctement que iterator.next() renvoie un objet du type suivant :

```ts
type IteratorNextType = {
  value: number | void;
  done: boolean;
};
```

Si vous souhaitez que la valeur d'ach√®vement de l'expression de rendement soit prot√©g√©e contre les erreurs de type, ajoutez une annotation de type √† la variable √† laquelle vous l'affectez :

```ts
function* generator(start: number) {
  const newStart: number = yield start + 1;
  yield newStart + 2;
}

var iterator = generator(0);
console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next(3)); // { value: 5, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

TypeScript d√©duit correctement que iterator.next() renvoie un objet du type suivant :

```ts
type IteratorNextType = {
  value: number | void;
  done: boolean;
};
```

Et maintenant, si vous essayez d'appeler `iterator.next('3')` au lieu de `iterator.next(3)`, vous obtiendrez une erreur de compilation üéâ.

## Comment typer les fonctions asynchrones avec Typescript ?

Les fonctions `async/await` en TypeScript fonctionnent exactement de la m√™me mani√®re qu'en JavaScript et la seule diff√©rence dans leur typage est que le type de retour sera toujours un g√©n√©rique `Promise`.

```ts
const sum = async (a: number, b: number): Promise<number> => a + b;
```

```ts
async function sum(a: number, b: number): Promise<number> {
  return a + b;
}
```

## Les fonctions avec des types g√©n√©riques

D√©claration d'une fonction

```ts
function arrayify2<Type>(a: Type): Array<Type> {
  return [a];
}
```

Malheureusement, avec une fonction fl√®ch√©e (lorsque TypeScript est configur√© pour JSX), l'ouverture `<` de la fonction est ambigu√´ pour le compilateur. "Est-ce de la syntaxe g√©n√©rique ? Ou est-ce du JSX ?" Vous devez donc ajouter un petit quelque chose pour l'aider √† d√©sambigu√Øser. Je pense que la chose la plus simple √† faire est de `extends unknown` :

```ts
const arrayify = <Type extends unknown>(a: Type): Array<Type> => [a];
```

Ce qui nous montre commod√©ment la syntaxe des extensions dans les g√©n√©riques.

### Protection de type (Type Guards)

Une protection de type est un m√©canisme permettant de r√©duire le nombre de types. Par exemple, il vous permet de r√©duire quelque chose qui est `string | number` √† une cha√Æne ou √† un nombre. Il existe des m√©canismes int√©gr√©s pour cela (comme typeof x === 'string'), mais vous pouvez √©galement cr√©er les v√¥tres. Voici l'un de mes pr√©f√©r√©s ([chapeau √† mon ami Peter](https://twitter.com/aprillion0042) qui me l'a montr√© √† l'origine) :

Vous avez un tableau avec des valeurs erron√©es et vous voulez les supprimer :

```ts
// Array<number | undefined>
const arrayWithFalsyValues = [1, undefined, 0, 2];
```

En JavaScript classique nous pouvons faire :

```ts
// Array<number | undefined>
const arrayWithoutFalsyValues = arrayWithFalsyValues.filter(Boolean);
```

Malheureusement, TypeScript ne consid√®re pas qu'il s'agit d'une garde de r√©tr√©cissement de type, donc le type est toujours `Array<number | undefined>` (aucun r√©tr√©cissement appliqu√©).

Nous pouvons donc √©crire notre propre fonction et indiquer au compilateur qu'elle renvoie vrai/faux pour savoir si l'argument donn√© est d'un type sp√©cifique. Pour nous, nous dirons que notre fonction renvoie vrai si le type de l'argument donn√© n'est pas inclus dans l'un des types de valeur `falsy`.

```ts
type FalsyType = false | null | undefined | '' | 0;
function typedBoolean<ValueType>(
  value: ValueType
): value is Exclude<ValueType, FalsyType> {
  return Boolean(value);
}
```

Et avec √ßa nous pouvons faire

```ts
// Array<number>
const arrayWithoutFalsyValues = arrayWithFalsyValues.filter(typedBoolean);
```

Woo!

## Fonctions d'assertion

Vous savez que parfois vous faites des v√©rifications au moment de l'ex√©cution pour √™tre plus s√ªr de quelque chose ? Par exemple, lorsqu'un objet peut avoir une propri√©t√© avec une valeur ou nulle, vous voulez v√©rifier si elle est nulle et peut-√™tre lancer une erreur si elle est nulle. Voici comment vous pouvez faire quelque chose comme √ßa :

```ts
type User = {
  name: string;
  displayName: string | null;
};

function logUserDisplayNameUpper(user: User) {
  if (!user.displayName) throw new Error('Oh no, user has no displayName');
  console.log(user.displayName.toUpperCase());
}
```

TypeScript accepte `user.displayName.toUpperCase()` parce que l'instruction if est une garde de type qu'il comprend. Maintenant, disons que vous voulez prendre cette v√©rification `if` et la mettre dans une fonction :

```ts
type User = {
  name: string;
  displayName: string | null;
};

function assertDisplayName(user: User) {
  if (!user.displayName) throw new Error('Oh no, user has no displayName');
}

function logUserDisplayName(user: User) {
  assertDisplayName(user);
  console.log(user.displayName.toUpperCase());
}
```

Maintenant, TypeScript n'est plus content parce que l'appel √† `assertDisplayName` n'est pas une protection de type suffisante. Je dirais que c'est une limitation de la part de TypeScript. H√©, aucune technologie n'est parfaite. Quoi qu'il en soit, nous pouvons aider TypeScript un peu en lui disant que notre fonction fait une assertion :
(voir ligne 8)

```ts
type User = {
  name: string;
  displayName: string | null;
};

function assertDisplayName(
  user: User
): asserts user is User & { displayName: string } {
  if (!user.displayName) throw new Error('Oh no, user has no displayName');
}

function logUserDisplayName(user: User) {
  assertDisplayName(user);
  console.log(user.displayName.toUpperCase());
}
```

Et c'est une autre fa√ßon de transformer notre fonction en une fonction de r√©tr√©cissement de type !

## Conclusion

Ce n'est certainement pas tout, mais c'est une grande partie de la syntaxe commune que je me retrouve √† √©crire lorsque je traite des fonctions dans TypeScript. J'esp√®re que cela vous a √©t√© utile ! Ajoutez cette page √† vos favoris et partagez-la avec vos amis üòò

(cr√©dit photo : Nubelson Fernandes sur unsplash.com)
