---
category: 'React'
date: '2021-11-08'
dateModified: '12 January 2022'
datePublished: '12 January 2022'
description: Am√©liorez les performances d'une application React en utilisant le hook d'effet useMemo()
image: '/images/memory.jpg'
isHome: true
slug: 'react-use-memo'
title: Am√©liorez les performances d'une application React en utilisant le hook d'effet useMemo()
metaTitle: Am√©liorez les performances d'une application React üöÄ en utilisant le hook d'effet useMemo()
metaDescription: Votre application React est lentre ? La solution est probablement le hook useMemo. Am√©liorez drastiquement les performances de votre siter internet React  en utilisant le hook d'effet useMemo() üöÄ
---

import { Image } from '@astrojs/image/components';
import banner from '@assets/images/react-usememo-memory.webp';

Avec la sortie de React 16.8, il existe de nombreux _hooks_ utiles que vous pouvez d√©sormais utiliser dans vos applications React.
L'un des _hooks_ int√©gr√©s qui a √©t√© introduit dans la version 16.8 est `useMemo`. Ce _hook_ a le potentiel d'am√©liorer les performances de votre application.

Cet article explore le fonctionnement du re-rendu dans React, pourquoi c'est une consid√©ration importante pour les applications React, et comment le hook useMemo peut l'exploiter pour cr√©er une augmentation des performances dans vos applications. Vous apprendrez √©galement quand `useMemo` peut causer des probl√®mes de performance.

<Image
  src={banner}
  height="672"
  height="997"
  format="avif"
  alt={`UseMemo React`}
  ratio="1920:2849"
/>

## √âgalit√© r√©f√©rentielle et op√©rations co√ªteuses

Il y a deux probl√®mes que useMemo cherche √† r√©soudre :

- l'√©galit√© r√©f√©rentielle
- les op√©rations co√ªteuses en termes de calcul

Dans le cycle de vie d'un composant, React refait le rendu du composant lorsqu'une mise √† jour est effectu√©e. Lorsque React v√©rifie les modifications apport√©es √† un composant, il peut d√©tecter un changement involontaire ou inattendu en raison de la fa√ßon dont JavaScript g√®re les comparaisons d'√©galit√© et superficielles. Ce changement dans l'application React entra√Ænera un nouveau rendu inutile.

De plus, si ce nouveau rendu est une op√©ration co√ªteuse, comme une longue boucle for, cela peut nuire aux performances. Les op√©rations on√©reuses peuvent √™tre co√ªteuses en temps, en m√©moire ou en traitement. En plus des probl√®mes techniques potentiels, cela peut conduire √† une mauvaise exp√©rience utilisateur.

Si une partie se rend √† nouveau, elle rend √† nouveau l'ensemble de l'arbre des composants.

Ainsi, React a lanc√© l'id√©e du m√©mo pour r√©soudre ce probl√®me.

## Qu'est-ce que la Memoization ?

La m√©morisation est une technique d'optimisation qui consiste √† passer une fonction complexe √† m√©moriser. Dans la m√©morisation, le r√©sultat est "m√©moris√©" lorsque les m√™mes param√®tres sont transmis par la suite.

Si nous avons une fonction qui calcule 1 + 1, elle retournera 2. Mais si elle utilise la m√©morisation, la prochaine fois que nous passerons des 1 dans la fonction, elle ne les additionnera pas ; elle se souviendra simplement que la r√©ponse est 2 sans ex√©cuter la fonction d'addition.

Dans la documentation officielle de React, la signature de useMemo ressemble √† ceci :

```jsx
const memoizedValue = React.useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

`useMemo` prend en param√®tre une fonction et un tableau de d√©pendances.

Les d√©pendances agissent comme des arguments dans une fonction. La liste des d√©pendances est l'√©l√©ment que useMemo surveille : s'il n'y a pas de changement, le r√©sultat de la fonction restera le m√™me. Sinon, il r√©ex√©cutera la fonction. S'ils ne changent pas, peu importe que tout notre composant soit modifi√©, la fonction ne sera pas r√©-ex√©cut√©e mais retournera le r√©sultat stock√©. Cela peut √™tre optimal si la fonction envelopp√©e est grande et co√ªteuse. _C'est l'utilisation principale de `useMemo`_.

## Exemple d'utilisation de useMemo ?

Voici un exemple abstrait d'utilisation de `useMemo` pour un tableau d'√©l√©ments qui utilise deux fonctions co√ªteuses en termes de calcul :

```jsx
const List = React.useMemo(
  () =>
    listOfItems.map((item) => ({
      ...item,
      itemProp1: expensiveFunction(props.first),
      itemProp2: anotherPriceyFunction(props.second),
    })),
  [listOfItems]
);
```

Dans l'exemple ci-dessus, la fonction `useMemo` s'ex√©cuterait au premier rendu. Elle bloquerait le thread jusqu'√† ce que les fonctions co√ªteuses soient termin√©es, car `useMemo` s'ex√©cute lors du premier rendu.

Au d√©part, cela n'aura pas l'air aussi propre que `useEffect`, puisque `useEffect` peut rendre une roue de chargement jusqu'√† ce que les fonctions co√ªteuses se terminent et que les effets se d√©clenchent.

Cependant, dans les rendus suivants, les fonctions co√ªteuses n'auront pas besoin d'√™tre ex√©cut√©es √† nouveau tant que listOfItems ne change pas. `useMemo` se "souviendra" de la valeur de retour de chaque fonction.

Ces fonctions co√ªteuses donneraient l'impression d'√™tre rendues instantan√©ment. C'est id√©al si vous avez une ou deux fonctions co√ªteuses et synchrones.

## Quand utiliser useMemo ?

√âcrivez d'abord le code, puis revisitez-le pour voir si vous pouvez l'optimiser. Si vous impl√©mentez `useMemo` trop souvent dans une application, cela peut nuire aux performances.

Lorsque vous envisagez de mettre en ≈ìuvre `useMemo`, vous pouvez utiliser des outils de profilage pour identifier les probl√®mes de performance co√ªteux. Un probl√®me co√ªteux signifie que l'application utilise beaucoup de ressources (comme la m√©moire). Si vous d√©finissez un bon nombre de variables dans une fonction au rendu, il est logique de m√©moriser avec `useMemo`.

## Utiliser le bon hook pour le travail

En plus de `useMemo`, il existe √©galement `useCallback`, `useRef` et `useEffect`.

Le _hook_ `useCallback` est similaire √† `useMemo`, mais il renvoie une fonction m√©moris√©e, alors que `useMemo` a une fonction qui renvoie une valeur.

Si votre tableau de d√©pendances n'est pas fourni, il n'y a aucune possibilit√© de m√©morisation, et il calculera une nouvelle valeur √† chaque rendu. Vous pouvez utiliser le hook useRef dans ce cas. L'avantage de `useMemo` par rapport √† `useRef` est une re-m√©morisation si les d√©pendances changent.

Vous ne voudrez pas que `useMemo` d√©clenche des effets secondaires ou des appels asynchrones. Dans ces cas, vous devriez utiliser `useEffect`.

## Conclusion

Cet article a explor√© le hook `useMemo` et quand il est appropri√© de l'utiliser dans une application React.

`useMemo` peut am√©liorer les performances d'une application en "m√©morisant" les fonctions co√ªteuses et en √©vitant un nouveau rendu √† chaque fois qu'un changement est apport√© √† l'application.

Bien que les performances puissent √™tre am√©lior√©es en utilisant ce hook, il peut √©galement ralentir votre application si vous l'utilisez trop. Plus vous utilisez ce crochet, plus votre application doit allouer de la m√©moire.
